    # VG EG DR HO SC
    # top:
    # cond: (step_cmp_num > 10) and percent > 0.9 -> val_xxx
    # once and forever
    # other percentile: 0.5

    # VG: (step:half1)
    # vg_rule1: median(grad_abs_ave) < p_vg1 ||| (p_vg1:1e-7)
    # vg_rule2: median(adjacent_quotient) < p_vg2 ||| (p_vg3:0.01)
    # vg_rule3: count(delta_loss=0) / max_epoch >= p_vg3 ||| (p_vg3:0.1)

    # EG: (step:half1)
    # eg_rule1: max(grad_abs_ave) > p_eg1 ||| (p_eg1:10)
    # eg_rule2: max(adjacent_quotient) > p_eg2 ||| (p_eg2:1000)
    # eg_rule3: loss >= cmp_median_loss * p_eg3 ||| (p_eg3:100)

    # DR: (step:all)
    # dr_rule1: any(rate0 > p_dr1) ||| (p_dr1:0.5)
    # dr_rule2: weighted_mean(rate0) > p_dr2 ||| (p_dr2:0.5)

    # SC: (step:half1) (wd:0.25)
    # sc_rule1: no_exist((acc[-1]-acc[0])/(1-acc[0]) > p_sc1) ||| (p_sc1:0.1)
    # sc_rule2: no_exist((loss[0]-loss[-1])/(loss[0]-0) > p_sc2) ||| (p_sc2:0.1)

    # HO: (step:half2) (wd:0.25)
    # heavy oscillation
    # ho_rule1: std(acc) / mean(acc) > p_ho1 ||| (p_ho1:?)
    # ho_rule2: std(log_loss) / mean(log_loss) > p_ho2 ||| (p_ho2:?)

    # NG: (step:half2) (wd:0.25)
    # no gain
    # ng_rule1: max(acc[-wd:]) < max(acc)
    # ng_rule2: min(loss[-wd:]) < min(loss)
    # ng_metric1: acc
    # ng_metric2: loss